//! Canonical ID generation for CP entities
//!
//! All CP identifiers are derived deterministically from content using BLAKE3.
//! IDs are 16 bytes (128 bits), formed by truncating the 32-byte BLAKE3 hash.
//!
//! This ensures:
//! - Content-addressed identity: same content = same ID, always
//! - Cross-platform determinism: no platform-specific UUID generation
//! - Collision resistance: 128-bit BLAKE3 truncation is cryptographically strong

use uuid::Uuid;

/// Generate a 16-byte content-addressed ID by truncating BLAKE3 hash.
///
/// Per CP-001 Â§2: "The 16-byte ID is generated by taking the first 16 bytes
/// of the BLAKE3 hash of the canonical representation."
pub fn generate_id(data: &[u8]) -> [u8; 16] {
    let hash = blake3::hash(data);
    let mut id = [0u8; 16];
    id.copy_from_slice(&hash.as_bytes()[..16]);
    id
}

/// Generate a 16-byte ID from multiple data segments.
///
/// Uses BLAKE3 keyed update for composite IDs (e.g., chunk = doc_id + seq + text).
pub fn generate_composite_id(segments: &[&[u8]]) -> [u8; 16] {
    let mut hasher = blake3::Hasher::new();
    for segment in segments {
        hasher.update(segment);
    }
    let hash = hasher.finalize();
    let mut id = [0u8; 16];
    id.copy_from_slice(&hash.as_bytes()[..16]);
    id
}

/// Convert a 16-byte ID to a `Uuid` for API compatibility.
///
/// CP uses Uuid as a convenient 16-byte container with Display/Serialize support,
/// but the bytes are BLAKE3-derived â€” not RFC 4122 UUIDs.
pub fn id_to_uuid(id: [u8; 16]) -> Uuid {
    Uuid::from_bytes(id)
}

/// Generate a full 32-byte BLAKE3 hash (for content hashing, not IDs).
pub fn content_hash(data: &[u8]) -> [u8; 32] {
    *blake3::hash(data).as_bytes()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_id_determinism() {
        let data = b"hello, CP!";
        let id1 = generate_id(data);
        let id2 = generate_id(data);
        assert_eq!(id1, id2);
    }

    #[test]
    fn test_generate_id_different_input() {
        let id1 = generate_id(b"hello");
        let id2 = generate_id(b"world");
        assert_ne!(id1, id2);
    }

    #[test]
    fn test_generate_id_length() {
        let id = generate_id(b"test");
        assert_eq!(id.len(), 16);
    }

    #[test]
    fn test_generate_composite_id_determinism() {
        let doc_id = [0u8; 16];
        let seq = 1u32.to_le_bytes();
        let text = b"chunk text";

        let id1 = generate_composite_id(&[&doc_id, &seq, text]);
        let id2 = generate_composite_id(&[&doc_id, &seq, text]);
        assert_eq!(id1, id2);
    }

    #[test]
    fn test_generate_composite_id_order_matters() {
        let a = b"aaa";
        let b_data = b"bbb";

        let id1 = generate_composite_id(&[a, b_data]);
        let id2 = generate_composite_id(&[b_data, a]);
        assert_ne!(id1, id2);
    }

    #[test]
    fn test_id_to_uuid_roundtrip() {
        let id = generate_id(b"test data");
        let uuid = id_to_uuid(id);
        assert_eq!(uuid.as_bytes(), &id);
    }

    #[test]
    fn test_generate_id_known_vector() {
        // BLAKE3("") first 16 bytes
        let empty_id = generate_id(b"");
        let full_hash = blake3::hash(b"");
        assert_eq!(&empty_id, &full_hash.as_bytes()[..16]);
    }

    #[test]
    fn test_content_hash_full_32_bytes() {
        let hash = content_hash(b"test");
        assert_eq!(hash.len(), 32);
        assert_eq!(hash, *blake3::hash(b"test").as_bytes());
    }
}
